# Copyright    2024    Xiaomi Corp.        (authors:  Wei Kang)
#
# See ../../../../LICENSE for clarification regarding multiple authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Optional, Tuple

import torch
import torch.nn as nn
import logging


class TtsModel(nn.Module):
    def __init__(
        self,
        encoder: nn.Module,
        in_embed_dim: int,
        out_embed_dim: int,
        in_feat_dim: int,
        feat_dim: int,
        vocab_size: int,
    ):
        """
        Args:
          num_channels: base channels of unet.
          feat_dim: dimension of spectrogram.
          vocab_size: vocabulary size.
        """
        super().__init__()

        self.encoder = encoder

        self.in_proj = nn.Linear(in_feat_dim, in_embed_dim)
        self.out_proj = nn.Linear(out_embed_dim, feat_dim)

        self.dur_in_proj = nn.Linear(feat_dim + 1, in_embed_dim)
        self.dur_out_proj = nn.Linear(out_embed_dim, 1)

        self.embed = nn.Embedding(vocab_size, feat_dim)

    def forward(
        self, t: torch.Tensor, xt: torch.Tensor, *args, **kwargs
    ) -> torch.Tensor:
        """Compute generator outputs.
        Args:
          t:
            A 2-D tensor of shape (N, 1) in the range of (0, 1).
          xt:
            Generated by `get_xt_and_ut`.

        Returns:
          vt:
            predicted d/dt (xt)
        """
        while t.dim() > 1:
            t = t[:, 0]
        if t.dim() == 0:
            t = t.repeat(xt.shape[1])

        return self.out_proj(self.encoder(t, self.in_proj(xt)))

    def forward_duration(
        self, t: torch.Tensor, dt: torch.Tensor, *args, **kwargs
    ) -> torch.Tensor:
        """Compute generator outputs.
        Args:
          t:
            A 2-D tensor of shape (N, 1) in the range of (0, 1).
          xt:
            Generated by `get_xt_and_ut`.

        Returns:
          vt:
            predicted d/dt (xt)
        """
        while t.dim() > 1:
            t = t[:, 0]
        if t.dim() == 0:
            t = t.repeat(dt.shape[1])

        return self.dur_out_proj(self.encoder(t, self.dur_in_proj(dt)))
